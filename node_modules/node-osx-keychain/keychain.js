const execAsync = require('mz/child_process').exec;
const path = require('path');

module.exports = class KeyChain {

  constructor(path, password) {
    this._chainPath = path;
    this._chainPassword = password;
  }

  async importP12(path, password) {
    await this.unlock();

    const result = await execAsync(
      `security import ${path} -k ${this._chainPath} -P ${password}`
    );

    if(result && result[0] && result[0].indexOf('identity imported') > -1) {
      // alright
    }
    else {
      throw new Error('error while import');
    }
  }

  // all items names
  async getItemsNames() {
    await this.unlock();
    const data = await execAsync(`security dump-keychain -d ${this._chainPath}`, {maxBuffer: 1024 * 500});

    return (data[0].match(/"labl"<blob>="(.*?)"/g) || [])
      .map(item => {
        if(!item)
          return ;

        const m = item.match(/labl"<blob>="(.*?)"/);
        if(m && m[1])
          return m[1];
      }).filter(i => !!i);
  }

  async unlock() {
    return execAsync(`security unlock-keychain -p ${this._chainPassword} ${this._chainPath}`)
  }

  async lock() {
    return execAsync(`security lock-keychain -p ${this._chainPassword} ${this._chainPath}`);
  }

  static async create(path, password) {
    await execAsync(`security create-keychain -p ${password} ${path}`);
    return new KeyChain(path, password);
  }

  static open(path, password) {
    return new KeyChain(path, password);
  }

  static async getList() {
    const result = await execAsync('security list-keychains');
    const items = result[0].split('\n').map(item => item.trim().replace(/"/g, ''));

    const list = {};
    for(let item of items)
      list[path.basename(item, 'keychain-db')] = {path: item};

    return list;
  }

};